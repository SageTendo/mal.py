import secrets
from typing import Optional
from urllib.parse import urlencode

import aiohttp

from mal.errors import (
    BadRequestError,
    HTTPError,
    NotFoundError,
    UnauthorizedError,
)
from mal.models import Anime, Auth, User

AUTH_URL = "https://myanimelist.net/v1"
BASE_URL = "https://api.myanimelist.net/v1"
N_BYTES = 96
QUERY_LIMIT = 100
TIMEOUT = 10
CODE_CHALLENGE_METHOD = "plain"


class Client:
    """
    Client used to interact with MyAnimeList API
    """

    __ANIME_FIELDS = (
        "id,title,main_picture,alternative_titles,start_date,end_date,synopsis,"
        "mean,rank,popularity,num_list_users,num_scoring_users,nsfw,genres,created_at,updated_at,"
        "media_type,status,my_list_status,num_episodes,start_season,broadcast,source,average_episode_duration,"
        "rating,pictures,background,related_anime,related_manga,recommendations,statistics,studios"
    )

    __USER_FIELDS = "id,name,picture,gender,birthday,location,joined_at,anime_statistics,time_zone,is_supporter"

    def __init__(
        self,
        *,
        client_secret: Optional[str] = None,
        client_id: Optional[str] = None,
        callback_url: Optional[str] = None,
        access_token: Optional[str] = None,
        session: Optional[aiohttp.ClientSession] = None,
    ):
        self._client_id = client_id
        self._client_secret = client_secret
        self._session = session or aiohttp.ClientSession()
        self._callback_url = callback_url

    async def close(self):
        await self._session.close()

    def _set_headers(self, args: dict):
        headers = args.pop("headers", {})

        token = args.pop("token", None)
        if not token and not self._client_id:
            raise ValueError("Client ID or User Access Token Must Be Provided")

        if token:
            headers["Authorization"] = f"Bearer {token}"

        if self._client_id:
            headers["X-MAL-CLIENT-ID"] = self._client_id

        headers["Content-Type"] = "application/json"
        headers["User-Agent"] = "Mal.py (https://github.com/SageTendo/mal.py)"
        args["headers"] = headers

    async def _get(self, url: str, **kwargs) -> dict:
        self._set_headers(kwargs)
        fields = kwargs.pop("fields", {})
        query_params = self.__to_query_string(fields)
        url += f"{url}?{query_params}" if query_params else ""

        async with self._session.get(url, **kwargs) as resp:
            data = await resp.json()

            if resp.status == 200:
                return data

            if resp.status == 400:
                raise BadRequestError(resp, data)
            if resp.status == 401:
                raise UnauthorizedError(resp, data)
            if resp.status == 403:
                raise UnauthorizedError(resp, data)
            if resp.status == 404:
                raise NotFoundError(resp, data)
            raise HTTPError(resp, data)

    async def _post(self, url: str, **kwargs) -> dict:
        self._set_headers(kwargs)
        async with self._session.post(url, **kwargs) as resp:
            data = await resp.json()

            if resp.status == 200:
                return data

            if resp.status == 400:
                raise BadRequestError(resp, data)
            if resp.status == 404:
                raise NotFoundError(resp, data)
            raise HTTPError(resp, data)

    def _check_required_oauth_info(self):
        if not self._client_id:
            raise ValueError("Client ID Must Be Provided For OAuth Flow")

        if not self._client_secret:
            raise ValueError("Client Secret Must Be Provided For OAuth Flow")

        if not self._callback_url:
            raise ValueError("Redirect URI Must Be Provided For OAuth Flow")

    def get_auth(self) -> tuple[str, str]:
        """
        Get the authorization URL for MyAnimeList API
        :return: Authorization URL & Code Verifier
        """
        self._check_required_oauth_info()
        state = secrets.token_urlsafe(N_BYTES)[:16]
        code_verifier, code_challenge = self.__generate_verifier_challenger_pair(
            128, method=CODE_CHALLENGE_METHOD
        )

        query_params = (
            f"response_type=code"
            f"&client_id={self._client_id}"
            f"&state={state}"
            f"&code_challenge={code_challenge}"
            f"&code_challenge_method={CODE_CHALLENGE_METHOD}"
            f"&redirect_uri={self._callback_url}"
        )
        return f"{AUTH_URL}/oauth2/authorize?{query_params}", code_verifier

    async def get_access_token(self, authorization_code: str, code_verifier: str):
        """
        Get the access token for MyAnimeList
        :param authorization_code: Generated by MAL API when a user authorizes the app
        :param code_verifier: A unique string generated upon every authorization request by the client
        :return: Access Token
        """
        self._check_required_oauth_info()
        data = {
            "client_id": self._client_id,
            "client_secret": self._client_secret,
            "grant_type": "authorization_code",
            "code": authorization_code,
            "code_verifier": code_verifier,
            "redirect_uri": self._callback_url,
        }

        resp = await self._post(url=f"{AUTH_URL}/oauth2/token", data=data)
        return Auth(resp)

    async def refresh_token(self, refresh_token: str):
        """
        Refresh the access token for MyAnimeList
        :param refresh_token: Refresh Token
        :return: Access Token
        """
        self._check_required_oauth_info()
        data = {
            "client_id": self._client_id,
            "client_secret": self._client_secret,
            "grant_type": "refresh_token",
            "refresh_token": refresh_token,
        }

        resp = await self._post(url=f"{AUTH_URL}/oauth2/token", data=data)
        return Auth(resp)

    async def get_user_details(self, *, token: str):
        """
        Get the user's details from MyAnimeList
        :param token: The user's access token
        :return: JSON response
        """
        if not token:
            raise ValueError("User Access Token Must Be Provided")

        url = f"{BASE_URL}/users/@me?fields={self.__USER_FIELDS}"
        resp = await self._get(url, token=token)
        return User(resp)

    async def get_user_anime_list(self, *, token: str, limit: int = 1):
        """
        Get a user's list of anime from MyAnimeList
        :param token: The user's access token
        :param limit: The number of results to return
        :param kwargs: Additional query parameters
        :return: JSON response
        """
        if not token:
            raise ValueError("User Access Token Must Be Provided")

        if limit < 1:
            limit = 1

        if limit > QUERY_LIMIT:
            limit = QUERY_LIMIT

        url = (
            f"{BASE_URL}/users/@me/animelist?limit={limit}&fields={self.__ANIME_FIELDS}"
        )
        resp = await self._get(url, token=token)
        return [Anime(anime["node"], client=self) for anime in resp["data"]]

    async def search_anime(
        self,
        *,
        query: str,
        limit: int = 1,
        offset: int = 0,
        token: Optional[str] = None,
        **kwargs,
    ):
        """
        Get a list of anime from MyAnimeList
        :param token: The user's access token
        :param query: The search query
        :param kwargs: Additional query parameters
        :return: JSON response
        """
        if not query:
            raise ValueError("A Valid Query Must Be Provided")

        if len(query) < 3:
            raise ValueError("Query Must Be At Least 3 Characters")

        if limit < 1:
            limit = 1

        if limit > QUERY_LIMIT:
            limit = QUERY_LIMIT

        url = f"{BASE_URL}/anime?q={query}?limit={limit}&fields={self.__ANIME_FIELDS}"
        resp = await self._get(url, token=token)
        return [Anime(anime["node"], client=self) for anime in resp["data"]]

    async def get_anime_details(
        self, *, anime_id: str, token: Optional[str] = None, **kwargs
    ):
        """
        Get anime details from MyAnimeList
        :param token: The user's access token
        :param anime_id: The ID of the anime to get details for
        :param kwargs: Additional query parameters
        :return: JSON response
        """
        if anime_id is None:
            raise Exception("A Valid Anime ID Must Be Provided")

        url = f"{BASE_URL}/anime/{anime_id}?fields={self.__ANIME_FIELDS}"
        resp = await self._get(url, token=token)
        return Anime(resp, client=self)

    async def update_watched_status(
        self,
        *,
        anime_id: str,
        episode: int,
        status: str = "watching",
        start_date: str = "",
        finish_date: str = "",
        token: Optional[str] = None,
    ):
        """
        Update the watched status of an anime in a user's watchlist
        :param token: The user's access token
        :param anime_id: The ID of the anime
        :param episode: The episode that is being watched
        :param status: The status to update the anime to
        :param start_date: The date the user started watching the anime
        :param finish_date: The date the user finished watching the anime
        :return: The details of the anime in the watchlist
        """
        if anime_id is None:
            raise Exception("A Valid Anime ID Must Be Provided")

        url = f"{BASE_URL}/anime/{anime_id}/my_list_status"
        body = {"status": status, "num_watched_episodes": episode}

        if start_date:
            body["start_date"] = start_date

        if finish_date:
            body["finish_date"] = finish_date

        resp = await self._post(url, data=body, token=token)
        return resp

    @staticmethod
    def __to_query_string(kwargs):
        """
        Convert Keyword arguments to a query string
        :param kwargs: The keyword arguments
        :return: query string
        """
        data = dict(**kwargs)
        return urlencode(data) if data else None

    def __generate_verifier_challenger_pair(self, length: int, method: str = ""):
        """
        Generate a verifier and challenge as a tuple
        :param length: The length of the verifier string
        :param method: The method to use to generate the challenge
        :return: verifier, challenge
        """
        verifier = self.__generate_verifier(length)
        return verifier, self.__generate_challenge(verifier, method)

    @staticmethod
    def __generate_verifier(length: int = 128):
        """
        Generate a random verifier string using the Secrets library
        :param length: The length of the verifier string
        :return: verifier
        """
        if not 43 <= length <= 128:
            raise ValueError("Param: 'Length' must be a min of 43 or a max of 128")
        return secrets.token_urlsafe(N_BYTES)[:length]

    @staticmethod
    def __generate_challenge(verifier, method):
        """
        Generate a challenge string using the Secrets library
        :param verifier: The verifier string
        :param method: The method to use to generate the challenge
        :return: the generated challenge
        """
        if not method or method == "plain":
            return verifier
        return None
